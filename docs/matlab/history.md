---
title: History of Computing
---

## Introduction
Computation, at its core, involves the processing of data and execution of instructions to solve problems.
From ancient mechanical devices to modern supercomputers, the field of computation has revolutionized how
engineers, scientists, and mathematicians address complex challenges.

Modern engineers often perform computations on personal computers, when it would be more time-intensive or
error-prone to do by hand.
Some computations, such as simulating turbulent flows, may grow beyond the limits of a personal computer and require
the use of computer clusters.
Others may be performed remotely, such as a rocket steering itself through launch.
This page highlights the most important computing advances through history, from the abacus to the modern computer.

## Early Beginnings: Mechanical Computation
The foundations of computation began with mechanical devices designed to aid calculations.
Ancient cultures like the Babylonians and Egyptians used tools such as the abacus for arithmetic tasks.
Farmers, for example, would use the abacus to track how many heads of cattle they owned.
The Inca used a system of knots to both add large numbers and record the individual terms of the sum.

A significant leap occurred in 1614, when [John Napier](https://www.britannica.com/biography/John-Napier) invented logarithms.
In the early 1620s, [William Oughtred](https://www.britannica.com/biography/William-Oughtred) invented the slide rule and fundamentally changed the way we performed multiplication, division, exponentiation, trigonometry, and solving the quadratic formula.
Use of the slide rule only declined in the 1970s when they were replaced by handheld calculators.
To learn more about multiplying and dividing with a slide rule, visit [Basic Slide Rule Use](https://efcms.engr.utk.edu/ef105-2024-01/slide_rule_fun.pdf).

Glenn L. Martin Hall, on the University of Maryland College Park campus,
was designed to look like a slide rule from above. ([aerial view](https://hdl.handle.net/1903.1/58268))
{: .notice}

It is worth noting at this point that the abacus adds and subtracts in discrete steps, while the slide rule is continuous.
For example, an abacus cannot add an irrational number (e.g. $$\pi$$) without rounding first.
Slide rules can be used without rounding, limited instead by the user's ability to line up the rules and cursor.
Though this may seem like an advantage for continuous computing machines, discrete machines would overtake them as technology advanced. 
Finer resolution, analogous to having many rows on an abacus for the tenths, hundredths, thousandths, and so on, would make round-off error nearly imperceptible.

<figure class="align-center">
	<a title="Jccsvq, CC0, via Wikimedia Commons" href="https://upload.wikimedia.org/wikipedia/commons/5/58/Traditional_Chinese_abacus_illustrating_the_suspended_bead_use.jpg">
    <img alt="Traditional suanpan (Chinese abacus) illustrating the use of suspended beads" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/Traditional_Chinese_abacus_illustrating_the_suspended_bead_use.jpg/512px-Traditional_Chinese_abacus_illustrating_the_suspended_bead_use.jpg"></a>
	<figcaption class="figure-caption text-center">Traditional suanpan (Chinese abacus) illustrating the use of suspended beads.</figcaption>
</figure>

<figure class="align-center">
    <a title="Pearson Scott Foresman, Public domain, via Wikimedia Commons" href="https://upload.wikimedia.org/wikipedia/commons/9/99/Slide_Rule_%28PSF%29.png"><img width="512" alt="Slide Rule (PSF)" src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/Slide_Rule_%28PSF%29.png/512px-Slide_Rule_%28PSF%29.png?20200326085333"></a>
    <figcaption class="figure-caption text-center">Diagram showing the use of a slide rule.</figcaption>
</figure>

## The Age of Machines: 17th to 19th Century
While the slide rule accelerated a long list of mathematical operations, addition and subtraction were not on that list.
Decades later in 1642, [Blaise Pascal](https://lemelson.mit.edu/resources/blaise-pascal) invented the Pascaline: a mechanical calculator capable of addition and subtraction.
It used a series of interlocking gears and dials, where each dial represented a digit.
Turning the dials would rotate the gears, calculating sums and differences automatically.

[Gottfried Wilhelm Leibniz](http://ds-wordpress.haverford.edu/bitbybit/bit-by-bit-contents/chapter-one/1-8-leibniz-and-the-stepped-reckoner/)
improved on the Pascaline in 1673 with the invention of the Leibniz wheel.
The wheel was a gear where the teeth had different widths,
so adding a specific number was a matter of sliding the wheel to set how many teeth engaged an axle.
All four fundamental arithmetic operations could be performed with a single Leibniz step reckoner,
a machine with a Leibniz wheel representing each of the tens places.
The stepped reckoner would remain the primary arithmetic machine in use for the next 150 years.

<figure class="align-center">
    <a title="Daderot, CC0, via Wikimedia Commons" href="https://upload.wikimedia.org/wikipedia/commons/3/39/Calculating_machine_replica%2C_Blaise_Pascal%2C_c._1642%2C_TM21265_-_Tekniska_museet_-_Stockholm%2C_Sweden_-_DSC01564.JPG"><img width="512" alt="Calculating machine replica, Blaise Pascal, c. 1642, TM21265 - Tekniska museet - Stockholm, Sweden - DSC01564" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/39/Calculating_machine_replica%2C_Blaise_Pascal%2C_c._1642%2C_TM21265_-_Tekniska_museet_-_Stockholm%2C_Sweden_-_DSC01564.JPG/512px-Calculating_machine_replica%2C_Blaise_Pascal%2C_c._1642%2C_TM21265_-_Tekniska_museet_-_Stockholm%2C_Sweden_-_DSC01564.JPG?20150816224806"></a>
    <figcaption class="figure-caption text-center">Pascaline replica at the National Museum of Science and Technology (Sweden).</figcaption>
</figure>

<figure class="align-center">
    <a title="J. A. V. Turck, Public domain, via Wikimedia Commons" href="https://upload.wikimedia.org/wikipedia/commons/b/b8/Leibniz_Stepped_Reckoner.png"><img width="512" alt="Leibnitz calculator (‘Staffelwalze’ = lit. step drum/cylinder ‘Stepped Reckoner’), 1694" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b8/Leibniz_Stepped_Reckoner.png/512px-Leibniz_Stepped_Reckoner.png?20080116124853"></a>
    <figcaption class="figure-caption text-center">Photograph of a Leibniz stepped reckoner discovered in 1879.</figcaption>
</figure>

The Industrial Revolution enabled mass production of nearly everything, including textiles and arithmetic machines.
In 1804, [Joseph Marie Jacquard](https://www.britannica.com/biography/Joseph-Marie-Jacquard) invented a programmable loom that could weave a wide variety of complex patterns,
with each pattern punched into a sequence of cards.
This improvement in automation, along with several other innovations, lead to significant job losses for skilled textile workers,
ignited conflicts across England, and highlighted the social impact of automating people's jobs.
In 1820, [Charles Xavier Thomas](http://ds-wordpress.haverford.edu/bitbybit/bit-by-bit-contents/chapter-two/the-arithmometer-and-numerical-tables/)
used the same operating principles as the step reckoner, improving on it with a design that could be mass produced.
His design would not reach the market until 1851, in part due to a shift in the British government's focus to the difference
engine invented by [Charles Babbage](https://www.britannica.com/biography/Charles-Babbage).

The Babbage [difference engine](https://www.britannica.com/technology/Difference-Engine) was notable for its ability to evaluate polynomials.
Previously, transcendental functions like sine and cosine were evaluated by looking up values in tables.
The publishers for these tables calculated and recorded values by hand - for a limited number of angles.
Babbage wanted to eliminate all sources of human error from tabulating these values and devised a machine that could
calculate the next row in a table based on the previous row and some intermediate values.
It was known for a century by this point that these functions could be approximated by a polynomial series, such as

$$\sin(x) \approx x - \frac{x^3}{3!} + \frac{x^5}{5!} + ...$$

Babbage's difference engine could be set with the coefficients of a polynomial, then evaluated for a specific input value.
Charles Babbage spent 19 years developing and building the difference engine, 
abandoning the project to create a programmable machine like the Jacquard looms - an engine capable of performing any sequence of calculations.
He set to work on the mechanical design of an [analytical engine](https://blogs.bodleian.ox.ac.uk/adalovelace/2018/07/26/ada-lovelace-and-the-analytical-engine/), while [Ada Lovelace](https://www.britannica.com/biography/Ada-Lovelace) wrote instructions for the machine, making her the first computer programmer.

{% capture notice-text %}
### Example: Finite Difference Table
#### Question
{:.no_toc}
Compute the first 5 entries in a finite difference table for the polynomial $f(x) = x-1000 x^5$, starting from $x=0$ and using a step size of $\Delta x = 0.01$. 
Compare the final value of $f(x)$ in the table with $sin(x)$ computed by calculator and find the percent error.
Use the following pre-computed differences:

| $x$ | $f(x)$ | $\Delta f$ | $\Delta_2 f$ | $\Delta_3 f$ | $\Delta_4 f$ | $\Delta_5 f$ |
|-----|--------|------------|--------------|--------------|--------------|--------------|
|   0 |      0 |       0.01 |        -3e-6 |       -1.5e5 |      -2.4e-5 |      -1.2e-5 |


#### Solution
{:.no_toc}

We start by populating the first row with the pre-computed differences.
In the next row, $\Delta_5$ remains constant, while $\Delta_4^{(new)}=\Delta_4^{(old)} + \Delta_5^{(old)}$.
The same applies for $\Delta_3$ and so on for the entire row.
This procedure is repeated for each row until we have 5 new rows.
Values below are given with 3 significant digits, but calculated with machine precision.

| $x$    | $f(x)$    | $\Delta f$ | $\Delta_2 f$ | $\Delta_3 f$ | $\Delta_4 f$ | $\Delta_5 f$ |
|--------|-----------|------------|--------------|--------------|--------------|--------------|
| 0      |      0    |       0.01 |     -3.00e-6 |     -1.50e-5 |     -2.40e-5 |     -1.20e-5 |
| 0.01   |   1.00e-2 |       0.01 |     -1.80e-5 |     -3.90e-5 |     -3.60e-5 |     -1.20e-5 |
| 0.02   |   2.00e-2 |    9.98e-3 |     -5.70e-5 |     -7.50e-5 |     -4.80e-5 |     -1.20e-5 |
| 0.03   |   3.00e-2 |    9.92e-3 |     -1.32e-4 |     -1.23e-4 |     -6.00e-5 |     -1.20e-5 |
| 0.04   |   3.99e-2 |    9.79e-3 |     -2.55e-4 |     -1.83e-4 |     -7.20e-5 |     -1.20e-5 |
| 0.05   |   4.97e-2 |    9.53e-3 |     -4.38e-4 |     -2.55e-4 |     -8.40e-5 |     -1.20e-5 |

The final value in the table is 0.0496875.
Computing the polynomial directly, using Microsoft Excel, yields 0.0496875.
There is 0% error between the method of finite differences and the direct calculation.

{% endcapture %}

<div class="notice--info">{{ notice-text | markdownify }}</div>

The significant improvement with the analytical engine was that the output of one calculation could be passed as input to another calculation.
The specific operations in each calculation step would be defined by the user with a punch card system,
inspired by the Jacquard looms. 
Though the analytical engine would never be built, the concepts of listing operations and storing values in memory became
fundamental to modern computing.

<figure class="align-center">
    <a title="Tulipasylvestris, CC0, via Wikimedia Commons" href="https://upload.wikimedia.org/wikipedia/commons/e/e5/Jacquardv%C3%A4vstol_med_stansade_h%C3%A5lkort_Norrk%C3%B6pings_stadsmuseum.jpg"><img width="256" alt="Jacquardvävstol med stansade hålkort Norrköpings stadsmuseum" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e5/Jacquardv%C3%A4vstol_med_stansade_h%C3%A5lkort_Norrk%C3%B6pings_stadsmuseum.jpg/256px-Jacquardv%C3%A4vstol_med_stansade_h%C3%A5lkort_Norrk%C3%B6pings_stadsmuseum.jpg?20210904193817"></a>
    <figcaption class="figure-caption text-center">Jacquard loom in Norrkoping City Museum (Sweden).</figcaption>
</figure>

<figure class="align-center">
    <a title="Ezrdr, Public domain, via Wikimedia Commons" href="https://upload.wikimedia.org/wikipedia/commons/1/13/Arithmometre_%28cropped%29.jpg"><img width="512" alt="Arithmometre (cropped)" src="https://upload.wikimedia.org/wikipedia/commons/1/13/Arithmometre_%28cropped%29.jpg?20231116170352"></a>
    <figcaption class="figure-caption text-center">Arithmometer from the late 1890s.</figcaption>
</figure>

<figure class="align-center">
    <a title="Sebastian Wallroth, Public domain, via Wikimedia Commons" href="https://upload.wikimedia.org/wikipedia/commons/f/f9/Babbages_difference_engine_1832.jpg"><img width="512" alt="Babbages difference engine 1832" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f9/Babbages_difference_engine_1832.jpg/512px-Babbages_difference_engine_1832.jpg?20120506181435"></a>
    <figcaption class="figure-caption text-center">Babbage difference engine No. 1 in Science Museum (London).</figcaption>
</figure>

<figure class="align-center">
    <a title="Tim Robinson, The Analytical Engine: 28 Plans and Counting" href="https://computerhistory.org/wp-content/uploads/2019/07/engine-structure.jpg"><img src="https://computerhistory.org/wp-content/uploads/2019/07/engine-structure.jpg" alt="drawing of the Babbage analytical engine."></a>
    <figcaption class="figure-caption text-center">Babbage analytical engine, with the "CPU" on the left and "memory" on the right. Science Museum (London).</figcaption>
</figure>

The video below demonstrates the working of Babbage's Difference Engine No. 2, an improved design that was realized later in 1991.

{% include video id="0anIyVGeWOI" provider="youtube" %}

## The Rise of Electronic Computing: 20th Century  
The early 20th century marked a pivotal shift from mechanical computation to electronic systems.  
As technological capabilities grew, engineers sought faster, more reliable ways to process information.  

### Theoretical Foundations  
In 1936, **Alan Turing** introduced the concept of the [Turing Machine](https://informatecdigital.com/en/the-turing-machine/).  
This abstract mathematical model defined the principles of computation.  
His work laid the theoretical groundwork for modern computer science.  
It demonstrated that any algorithmic process could be represented with a set of logical steps.  

A Turing Machine operates like a basic mechanical computer that follows a set of rules to manipulate symbols on an infinite tape.  
Imagine the tape as a long row of boxes, each containing a single character.  
A **read/write head** moves along the tape, examining one box at a time and following predefined instructions.  
At each step, the machine can:  
- Read the symbol in the current box.  
- Write a new symbol in the box, replacing the old one.  
- Move left or right along the tape to examine the next box.  
- Change its internal state, which helps track progress in solving a problem.  

Although this machine is simple, it is capable of performing any step-by-step computational task.  
Modern computers work similarly—they process information by following sequences of instructions stored in memory.  
Just as a Turing Machine can execute a series of logical steps, today’s processors execute programs by manipulating numbers and symbols according to rules set by a programmer.  
The fundamental ideas behind the Turing Machine—storing, reading, and modifying data sequentially—are key to understanding how software operates on hardware.  

This simple yet powerful model established the theoretical limits of computation.  
It led to the **Church-Turing Thesis**, which states that any function computable by an algorithm can be computed by a Turing Machine.  
This principle underpins modern programming languages and computer architecture.  
Turing’s work also influenced the development of stored-program computers, where instructions and data are treated similarly.  
This concept became the basis for modern digital computers.  

Although Turing did not build a physical Turing Machine, his ideas directly influenced real-world computers.  
During World War II, he worked at **Bletchley Park**, where he helped design the **Bombe**, an electromechanical device used to break German Enigma codes.  
Later, his work contributed to the development of early computers like the **ACE (Automatic Computing Engine)**.

{% capture notice-text %}
### Example: Turing Machine  
#### Question  
{:.no_toc}  
Create the list of steps for a Turing machine that adds 1 to a 4-bit unsigned integer.
For example, if the tape holds the binary for 7, `0111`, the end result of the list of steps
should be the binary for 8, `1000`.

#### Solution  
{:.no_toc}  
The machine starts at the rightmost digit of the binary number.  
It follows these rules:  
1. If the digit is **0**, change it to **1** and halt.  
2. If the digit is **1**, change it to **0** and move left.  
3. Repeat step 2 until a **0** is found or a new digit is added to the tape.  

Processing steps:  

| Step | Tape Content | Read Digit | Action        | Updated Tape | Move Direction |  
|------|--------------|------------|---------------|--------------|----------------|  
| 1    | `0111`       | `1`        | Change to `0` | `0110`       | Left           |  
| 2    | `0110`       | `1`        | Change to `0` | `0100`       | Left           |  
| 3    | `0100`       | `1`        | Change to `0` | `0000`       | Left           |  
| 4    | `0000`       | `0`        | Change to `1` | `1000`       | Halt           |  

The final tape content is `1000`.  
This correctly represents the binary increment of 7 to 8.  

{% endcapture %}  

<div class="notice--info">{{ notice-text | markdownify }}</div>   

### Pioneering Electronic Machines  
The first practical application of electronic computation came in the 1940s.  
It was developed with the **ENIAC** (Electronic Numerical Integrator and Computer).  
Completed in 1945, ENIAC was the first general-purpose electronic computer.  
It was capable of performing thousands of calculations per second.  
It was primarily used for military applications, including artillery trajectory calculations.  

In 1953, IBM introduced the **Model 650**.  
This was one of the earliest commercial computers designed specifically for engineering applications.  
Unlike previous systems that relied on vacuum tubes, the Model 650 incorporated magnetic drum memory.  
This improved data storage and processing capabilities.  
It made computers more accessible to universities and research institutions.  

### Computational Applications in Aerospace  
During this era, aerospace engineers began using electronic computation to model flight dynamics.  
They also used it to analyze structural integrity.  
Early electronic computers allowed for complex aerodynamic simulations.  
These simulations would have been impossible with purely mechanical devices.  

**Suggested Image:** A photograph of the ENIAC computer in operation, with engineers working alongside the massive machine.  

---

## Computational Power in Engineering: Late 20th Century  
The late 20th century witnessed rapid advancements in computational hardware and software.  
These advancements transformed engineering fields.  

### The Rise of Personal Computing  
The introduction of personal computers in the 1980s revolutionized computation.  
It made powerful tools accessible to engineers worldwide.  
Previously, large mainframes dominated the industry.  
Smaller computers provided flexibility and efficiency.  

Key software innovations emerged during this period.  
One of these was **MATLAB** (introduced in 1984).  
It allowed engineers to perform numerical computations, analyze data, and create simulations.  
MATLAB quickly became a staple in scientific and engineering research.  
Its ease of use and robust mathematical capabilities made it invaluable.  

**Computer-Aided Design (CAD)** tools also gained prominence.  
They enabled engineers to develop precise digital models of mechanical components, buildings, and complex systems.  
This shift significantly improved design accuracy and efficiency.  

### Supercomputing and Parallel Processing  
By the 1990s, supercomputers played a crucial role in solving large-scale engineering problems.  
**Parallel computing** became instrumental in fields such as:  
- **Finite Element Analysis**: Modeling stress distributions in materials.  
- **Fluid Dynamics Simulations**: Predicting airflow around aircraft and spacecraft.  
- **Weather and Climate Modeling**: Analyzing large-scale atmospheric patterns.  

These advancements paved the way for increasingly sophisticated engineering applications.  

**Suggested Image:** A timeline showing the progression of computational tools like MATLAB, CAD software, and supercomputers.  

---

## The Modern Era: 21st Century and Beyond  
Modern computation continues to evolve rapidly.  
It enables engineers to tackle increasingly complex challenges.  

### Artificial Intelligence and Machine Learning  
The integration of **AI and Machine Learning** has transformed engineering workflows.  
Predictive modeling, automated data analysis, and optimization algorithms assist in designing efficient aircraft.  
They also help manage mechanical systems and advance robotics.  

### Cloud Computing and Distributed Processing  
With the rise of **cloud computing**, engineers can now perform complex simulations remotely.  
They can collaborate across different locations without requiring dedicated high-performance hardware on-site.  
This innovation has improved accessibility and efficiency in research and industry.  

### Quantum Computing: The Next Frontier  
Emerging **quantum computing** technologies offer revolutionary possibilities for engineering computation.  
Unlike classical computers that process information as binary bits (0s and 1s), quantum computers leverage qubits.  
Qubits exist in multiple states simultaneously.  
This approach could dramatically accelerate calculations for fields like:  
- **Aerodynamic modeling**: Simulating turbulence at unprecedented resolution.  
- **Structural engineering**: Optimizing materials for extreme conditions.  
- **Cryptography**: Enhancing security in aerospace communications.  

### The Future of Engineering Computation  
Today, engineers continue to push boundaries using advanced computational power in:  
- **Autonomous Systems**: AI-driven control mechanisms for spacecraft, drones, and robots.  
- **Energy Efficiency**: Optimizing fuel consumption and renewable energy sources.  
- **Space Exploration**: Simulating deep-space missions and planetary environments.  

**Suggested Image:** A futuristic rendering of a quantum computer connected to engineering simulations.  

---

## Conclusion  
The history of computation is a story of human ingenuity.  
It is driven by the desire to solve complex problems efficiently.  
From ancient mechanical devices to cutting-edge quantum systems, computation continues to evolve.  
It empowers engineers, scientists, and mathematicians to push boundaries and explore new frontiers.  

**Suggested Image:** A conceptual image of an engineer working in a modern computational environment.  
This environment includes overlays of simulations and calculations.
